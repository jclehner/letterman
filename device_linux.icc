#include <libudev.h>
#include <fstream>
#include <sstream>
#include <memory>
#include <string>
#include <map>
#include "device.h"
#include "util.h"
using namespace std;

namespace letterman {
	namespace {
		static const char* PROPS[] = {
			"DEVNAME", "ID_PART_ENTRY_OFFSET", "ID_PART_ENTRY_NUMBER", "ID_FS_LABEL",
			"ID_FS_LABEL_ENC", "UDISKS_PARTITION_NUMBER", "UDISKS_PARTITION_OFFSET",
			"ID_DRIVE_FLOPPY", "MAJOR", "MINOR", "ID_SERIAL", "ID_SERIAL_SHORT"
		};

		typedef map<string, string> PropMap;
		template<typename T> using UdevUniquePtr = unique_ptr<T, std::function<void(T*)>>;

		map<string, PropMap> findEntriesWithUdevProps(const PropMap& criteria)
		{
			UdevUniquePtr<udev> udev(udev_new(), [] (struct udev* p) { udev_unref(p); });
			if (!udev) {
				throw ErrnoException("udev_new");
			}

			UdevUniquePtr<udev_enumerate> enumerate(udev_enumerate_new(udev.get()), 
					[] (udev_enumerate* p) { udev_enumerate_unref(p); });

			udev_enumerate_add_match_subsystem(enumerate.get(), "block");
			udev_enumerate_scan_devices(enumerate.get());

			udev_list_entry *devices, *dev_list_entry;
			devices = udev_enumerate_get_list_entry(enumerate.get());

			map<string, PropMap> entries;

			udev_list_entry_foreach(dev_list_entry, devices) {

				const char* path = udev_list_entry_get_name(dev_list_entry);
				UdevUniquePtr<udev_device> dev(udev_device_new_from_syspath(udev.get(), path),
						[] (udev_device* p) { udev_device_unref(p); });

				bool skip = false;

				for (auto& c : criteria) {
					if (c.second.empty()) continue;

					const char* val = udev_device_get_property_value(dev.get(), c.first.c_str());
					if (!val || val != c.second) {
						skip = true;
						break;
					}
				}

				if (skip) continue;

				PropMap propMap;

				for (const char* key : PROPS) {
					const char* prop = udev_device_get_property_value(dev.get(), key);
					propMap[key] = prop ? prop : "";
				}

				if (!propMap.empty()) {
					entries[propMap["DEVNAME"]] = propMap;
				}
			}

			return entries;
		}

		PropMap findEntryWithUdevProps(const PropMap& criteria)
		{
			map<string, PropMap> entries(findEntriesWithUdevProps(criteria));
			if (!entries.empty()) {
				return entries.begin()->second;
			}

			return PropMap();
		}

		PropMap findEntryWithUdevProp(const string& type, const string& key, const string& value)
		{
			PropMap criteria = {
				{"DEVTYPE", type}, {key, value}};
			return findEntryWithUdevProps(criteria);
		}

		string findDiskById(uint32_t id)
		{
			PropMap criteria = {{"DEVTYPE", "disk"}};
			map<string, PropMap> disks(findEntriesWithUdevProps(criteria));
			for (auto& disk : disks) {
				if (!disk.second["ID_DRIVE_FLOPPY"].empty()) continue;

				ifstream mbr(disk.first.c_str());
				if (!mbr.good() || !mbr.seekg(440)) {
					continue;
				}

				uint32_t mbrId;
				if(!mbr.read(reinterpret_cast<char*>(&mbrId), 4)) {
					continue;
				}

				if(le32toh(mbrId) == id) {
					return disk.first;
				}
			}

			return "";
		}
	}

	string MbrPartitionDevice::osDeviceName() const
	{
		ostringstream ostr;
		ostr << setfill('0') << hex << setw(8) << _disk;

		// ID_PART_TABLE_UUID is not available in some udev
		// versions (Ubuntu 14.04 for example)
		PropMap criteria = {
			{"DEVTYPE", "disk"}, {"ID_PART_TABLE_UUID", ostr.str()}};

		PropMap props(findEntryWithUdevProps(criteria));
		string disk(props["DEVNAME"]);
		if (disk.empty() && geteuid() == 0) {
			disk = findDiskById(_disk);
		}

		if (disk.empty()) {
			ostr.str("");
			ostr << "(disk " << hex << setw(8) << _disk << " @ block " << dec << setw(0) 
				<< (_offset / 512) << ")";
			return ostr.str();
		}

		// We have the disk, but no partition yet. Lookup the
		// props of the entry with DEVNAME=disk, so we can
		// associate the partition to its disk

		criteria["ID_PART_TABLE_UUID"] = "";
		criteria["DEVNAME"] = disk;

		props = findEntryWithUdevProps(criteria);


		criteria["DEVNAME"] = "";
		criteria["DEVTYPE"] = "partition";

		// Searching for a partition by offset only might yield
		// ambiguous results, especially if the partition in question
		// is the first partition with an offset of 2 or 63 blocks
		// (depending on the partitioning utility used).

		if (!props["ID_SERIAL"].empty()) {
			criteria["ID_SERIAL"] = props["ID_SERIAL"];
		} else {
			criteria["ID_PART_ENTRY_DISK"] = props["MAJOR"] + ":" + props["MINOR"];
		}

		criteria["ID_PART_ENTRY_OFFSET"] = util::toString(_offset / 512);

		props = findEntryWithUdevProps(criteria);
		string part(props["DEVNAME"]);
		if (!part.empty()) {
			return part;
		}

		criteria["ID_PART_ENTRY_OFFSET"] = "";
		criteria["UDISKS_PARTITION_OFFSET"] = util::toString(_offset);

		props = findEntryWithUdevProps(criteria);
		part = props["DEVNAME"];
		if (!part.empty()) {
			return part;
		}

		return disk + "? (offset " + util::toString(_offset / 512) + " blocks)";
	}

	string GuidPartitionDevice::osDeviceName() const
	{
		string guid(_guid);
		transform(guid.begin(), guid.end(), guid.begin(), ::tolower);

		PropMap props(findEntryWithUdevProp("partition", "ID_PART_ENTRY_UUID", guid));
		string disk(props["DEVNAME"]);
		return disk.empty() ? "(not attached)" : disk;
	}
}
