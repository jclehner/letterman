#include <libudev.h>
#include <sstream>
#include <memory>
#include <string>
#include <map>
#include "device.h"
#include "util.h"
using namespace std;

namespace letterman {
	namespace {
		static const char* PROPS[] = {
			"DEVNAME", "ID_PART_ENTRY_OFFSET", "ID_PART_ENTRY_NUMBER", "ID_FS_LABEL",
			"ID_FS_LABEL_ENC", "UDISKS_PARTITION_NUMBER", "UDISKS_PARTITION_OFFSET" 
		};

		typedef map<string, string> PropMap;
		template<typename T> using UdevUniquePtr = unique_ptr<T, std::function<void(T*)>>;

		PropMap findEntryWithUdevProps(const PropMap& criteria)
		{
			UdevUniquePtr<udev> udev(udev_new(), [] (struct udev* p) { udev_unref(p); });
			if (!udev) {
				throw ErrnoException("udev_new");
			}

			UdevUniquePtr<udev_enumerate> enumerate(udev_enumerate_new(udev.get()), 
					[] (udev_enumerate* p) { udev_enumerate_unref(p); });

			udev_enumerate_add_match_subsystem(enumerate.get(), "block");
			udev_enumerate_scan_devices(enumerate.get());

			udev_list_entry *devices, *dev_list_entry;
			devices = udev_enumerate_get_list_entry(enumerate.get());

			udev_list_entry_foreach(dev_list_entry, devices) {

				const char* path = udev_list_entry_get_name(dev_list_entry);
				UdevUniquePtr<udev_device> dev(udev_device_new_from_syspath(udev.get(), path),
						[] (udev_device* p) { udev_device_unref(p); });

				bool skip = false;

				for (auto& c : criteria) {
					if (c.second.empty()) continue;

					const char* val = udev_device_get_property_value(dev.get(), c.first.c_str());
					if (!val || val != c.second) {
						skip = true;
						break;
					}
				}

				if (skip) continue;

				PropMap propMap;

				for (const char* key : PROPS) {
					const char* prop = udev_device_get_property_value(dev.get(), key);
					propMap[key] = prop ? prop : "";
				}

				if (!propMap.empty()) {
					return propMap;
				}
			}

			return PropMap();
		}

		PropMap findEntryWithUdevProp(const string& type, const string& key, const string& value)
		{
			PropMap criteria;
			criteria["DEVTYPE"] = type;
			criteria[key] = value;
			return findEntryWithUdevProps(criteria);
		}

		uint64_t getPartOffset(const PropMap& props)
		{
			string str(props.at("UDISKS_PARTITION_OFFSET"));
			if (str.empty()) {
				str = props.at("ID_PART_ENTRY_OFFSET");
			}

			uint64_t offset;
			istringstream istr(str);
			if (istr >> offset) {
				return offset;
			} 

			throw invalid_argument("offset " + str);
		}
	}

	string MbrPartitionDevice::osDeviceName() const
	{
		ostringstream ostr;
		ostr << setfill('0') << hex << setw(8) << _disk;

		PropMap criteria = {
			{"DEVTYPE", "disk"}, {"ID_PART_TABLE_UUID", ostr.str()}};


		PropMap props(findEntryWithUdevProps(criteria));
		string disk(props["DEVNAME"]);
		if (disk.empty()) {
			ostr.str("");
			ostr << "(disk " << hex << setw(8) << _disk << " @ block " << dec << setw(0) 
				<< (_offset / 512) << ")";
			return ostr.str();
		}

		// we have the disk, but no partition yet

		criteria["DEVTYPE"] = "partition";
		criteria["ID_PART_ENTRY_OFFSET"] = util::toString(_offset / 512);

		props = findEntryWithUdevProps(criteria);
		string part(props["DEVNAME"]);
		if (!part.empty()) {
			return part;
		}

		criteria["ID_PART_ENTRY_OFFSET"] = "";
		criteria["UDISKS_PARTITION_OFFSET"] = util::toString(_offset);

		props = findEntryWithUdevProps(criteria);
		part = props["DEVNAME"];
		if (!part.empty()) {
			return part;
		}

		return disk + "? (offset " + util::toString(_offset / 512) + " blocks)";
	}

	string GuidPartitionDevice::osDeviceName() const
	{
		string guid(_guid);
		transform(guid.begin(), guid.end(), guid.begin(), ::tolower);

		PropMap props(findEntryWithUdevProp("partition", "ID_PART_ENTRY_UUID", guid));
		string disk(props["DEVNAME"]);
		return disk.empty() ? "(not attached)" : disk;
	}
}
